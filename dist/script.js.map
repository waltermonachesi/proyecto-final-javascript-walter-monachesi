{"version":3,"names":[],"mappings":"","sources":["script.js"],"sourcesContent":["/* \r\nCreamos un objeto teniendo en cuenta los parámetros que nos devuelve la API en la docmuentación de la misma. \r\nLink: https://www.pexels.com/es-es/api/documentation/#photos-overview.\r\n*/\r\nclass Photo {\r\n    // Creamos el constructor de la clase a partir de las propiedades del objeto dado por un json de una API.\r\n    constructor(json){\r\n        Object.assign(this, json);\r\n    }\r\n    showModal(){\r\n        Swal.fire({\r\n            width: '50rem',\r\n            imageUrl: this.src.large2x,\r\n            imageWidth: '60%',  \r\n            showConfirmButton: false,  \r\n            imageAlt: this.alt,\r\n            footer: `<p>Foto por: ${this.photographer}</p>`\r\n        });\r\n    }\r\n}\r\n\r\n// La API key que pedí a la API de Pexels.\r\nconst API_KEY = '563492ad6f9170000100000124f75ece770b47a49b4bfa89770d506a';\r\n// Guardo los headers en una constante para usarlos cuando necesite hacer un fetch.\r\nconst HEADERS = {\r\n    method: 'GET', \r\n    headers: {\r\n        Accept: 'application/json',\r\n        Authorization: API_KEY\r\n    }\r\n}\r\n\r\n// Definimos los elementos del DOM que necesitaremos.\r\nlet topBtn = document.getElementById('topBtn')\r\nlet loadMoreBtn = document.getElementById('loadMoreBtn');\r\nlet errorAlert = document.getElementById('errorAlert');\r\nlet clearInputButton = document.getElementById('clearInput');\r\nlet searchForm = document.getElementById('searchForm');\r\nlet gallery = document.getElementById('gallery');\r\nlet galleryContainer = document.getElementById('galleryContainer');\r\n\r\n\r\n// Creamos una función que nos permita eliminar todos los hijos de un elemento.\r\nconst removeAllChild = (parent) => {\r\n    // Evalua que mientras tenga hijos, los va a eliminar.\r\n    while (parent.firstChild) {\r\n        parent.removeChild(parent.firstChild);\r\n    }\r\n}\r\n\r\n// Definimos algunas variables globales que necesitaremos.\r\nlet pageIndex = 1;\r\nlet searchValue;\r\n\r\n// Creamos una función que nos permita realizar el fetch a partir de una URL y retornar la 'data' para asi trabajarla como querramos.\r\nconst fetchPhotos = async (baseURL) => {\r\n    const res = await fetch(baseURL, HEADERS);\r\n    const data = await res.json();\r\n    return data;\r\n}\r\n\r\n// Creamos una función que valide lo ingresado por el usuario.\r\nconst validateSearchValue = (searchValue) => {\r\n    if (searchValue.length < 3){\r\n        // Avisamos el error.\r\n        errorAlert.innerText = 'Debe introducir una palabra mayor a 3 letras.';\r\n        // Creamos un timer que limpie el 'errorAlert' despues de 1.5 segundos.\r\n        setTimeout(() => {\r\n            errorAlert.innerText = '';\r\n        }, 1500);\r\n    }else{\r\n        return true;\r\n    }\r\n}\r\n\r\n// Creamos una función que nos permita mapear las fotos devueltas por la API, crear una instancia del objeto Photo a partir de los datos de la API, y crear su respectivo elemento en HTML.\r\nconst generateHTML = (data, photoType) => {\r\n    data.photos.forEach((photoObject) => {\r\n        const photo = new Photo(photoObject);\r\n        // Creamos un nuevo elemento article.\r\n        let newGalleryItem = document.createElement('article');\r\n        // Le asignamos la clase que define los estilos que poseerán las fotos.\r\n        newGalleryItem.classList.add('gallery__item');\r\n        // Le asignamos un atributo 'data-photo' para poder saber si la foto es el resultado de una búsqueda o es una foto random.\r\n        newGalleryItem.setAttribute('data-photo', photoType);\r\n        // Y le ponemos una etiqueta img con los datos del objeto para que se muestren.\r\n        newGalleryItem.innerHTML = `<img src=\"${photo.src.large}\" alt=\"${photo.alt}\"></img>`;\r\n        // Y por último le agregamos ese nuevo elemento a la galería.\r\n        galleryContainer.append(newGalleryItem);\r\n        // Por último, cuando se realiza click sobre un elemento de la galería se lanza el método 'showModal'.\r\n        newGalleryItem.addEventListener('click', () => photo.showModal());\r\n    });\r\n}\r\n\r\n// Creamos una función que nos permita validar algunos errores para asi mostrarlos por el HTML.\r\nconst validateErrors = (data, searchValue) => {\r\n    // Si no tiene más paginaciones, oculta el botoón de cargar más fotos.\r\n    if (!data.next_page){\r\n        loadMoreBtn.style.display = 'none'\r\n    }\r\n    // Si la API nos devuelve una array vacio, por medio de un H2 informamos el error.\r\n    if (data.photos.length === 0){\r\n        let textError = document.createElement('h2');\r\n        textError.innerText = `No se encontraron fotos de '${searchValue}'`;\r\n        gallery.prepend(textError);\r\n    }\r\n}\r\n\r\n// Creamos una función que nos devuelva las fotos a partir de lo ingresado por el usuario en la barra de búsqueda.\r\nconst getSearchedPhotos = async (e) => {\r\n    e.preventDefault();\r\n    // Capturamos el valor del input mediante el evento.\r\n    searchValue = e.target.querySelector('input').value;\r\n    // Y lo validamos.\r\n    if (validateSearchValue(searchValue) === true){\r\n        // Realizamos el fetch de la petición.\r\n        const data = await fetchPhotos(`https://api.pexels.com/v1/search?query=${searchValue}&per_page=16`);\r\n        // Validamos los errores si los hay.\r\n        validateErrors(data, searchValue);\r\n        // Vaciamos el contenedor de la galería.\r\n        removeAllChild(galleryContainer);\r\n        // Cargamos los nuevos items de la galería.\r\n        generateHTML(data, 'search');\r\n    }\r\n}\r\n\r\n// Creamos una función que nos devuelva otras páginas de fotos respecto de la búsqueda anterior.\r\nconst getMoreSearchedPhotos = async (index) => {\r\n    // Realizamos el fetch de la petición.\r\n    const data = await fetchPhotos(`https://api.pexels.com/v1/search?query=${searchValue}&per_page=16&page=${index}`);\r\n    // Validamos los errores si los hay.\r\n    validateErrors(data, searchValue);\r\n    // Cargamos los nuevos items de la galería.\r\n    generateHTML(data, 'search');\r\n}\r\n\r\n// Creamos una función que nos devuelva fotos aleatorias.\r\nconst getInitialRandomPhotos = async (index) => {\r\n    // Realizamos el fetch de la petición.\r\n    const data = await fetchPhotos(`https://api.pexels.com/v1/curated?per_page=16&page=${index}`);\r\n    // Verificamos si no tiene otra página de paginación para no mostrar más el botón.\r\n    if (!data.next_page){\r\n        loadMoreBtn.style.display = 'none'\r\n    }\r\n    // Cargamos los nuevos items de la galería.\r\n    generateHTML(data, 'curated');\r\n}\r\n\r\n// Creamos una funcióm que nos permita cargar las paginaciones dependiendo del tipo de foto.\r\nconst loadMorePhotos = () => {\r\n    let index = ++pageIndex;\r\n    let galleryItem = document.querySelector('article');\r\n    let dataPhoto = galleryItem.getAttribute('data-photo')\r\n    // Según el valor del 'data-photo' se llama a la función que corresponde.\r\n    if (dataPhoto == 'curated'){\r\n        getInitialRandomPhotos(index); // Función para fotos random.\r\n    }else{\r\n        getMoreSearchedPhotos(index); // Función para fotos buscadas.\r\n    }\r\n}\r\n\r\n// Creamos una función que nos permita limpiar el 'value' del input además de limpiar la galería según su contenido.\r\nconst clearInputAndGallery = () => {\r\n    let pageIndex = 1;\r\n    // Limpiamos el input.\r\n    document.getElementById('searchInput').value = '';\r\n    // Cuando la galería tiene 5 hijos es porque no se tuvo que crear el h2 para error. Sino, si se tuvo que crear el h2 por lo que tiene más hijos.\r\n    if (gallery.childNodes.length === 5){\r\n        // Borra los hijos del contenedor de la galería.\r\n        removeAllChild(galleryContainer);\r\n        // Carga las fotos aleatorias del principio.\r\n        getInitialRandomPhotos(pageIndex);\r\n    }else{\r\n        // Borra el h2 con el error.\r\n        gallery.childNodes[0].remove();\r\n        // Borra los hijos del contenedor de la galería.\r\n        removeAllChild(galleryContainer);\r\n        // Carga las fotos aleatorias del principio.\r\n        getInitialRandomPhotos(pageIndex);\r\n    }\r\n    // Mostramos el botón de cargar más fotos.\r\n    loadMoreBtn.style.display = 'flex';\r\n}\r\n\r\n\r\n/****  EVENTOS  ****/\r\n\r\n// Cuando se carge la ventana, llamamos a la función que nos carga 8 fotos simulando que son fotos aleatorias.\r\ndocument.addEventListener('DOMContentLoaded', getInitialRandomPhotos(pageIndex));\r\n// Evento submit del form, donde se llama a una función que trae las fotos a partir de la búsqueda.\r\nsearchForm.addEventListener('submit', (e) => getSearchedPhotos(e));\r\n// Evento click del botón para cargar más fotos mediante las paginaciones de la API.\r\nloadMoreBtn.addEventListener('click', () => loadMorePhotos());\r\n// Evento click del botón para limpiar el input y la galería.\r\nclearInputButton.addEventListener('click', () => clearInputAndGallery());\r\n// Evento para el botón de volver arriba.\r\nwindow.addEventListener(\"scroll\", () => {\r\n    if (window.scrollY > 1){\r\n        // Si se hace scroll, se muestra el botón cambiandole el display.\r\n        topBtn.style.display = 'flex';\r\n    }else if(window.scrollY < 1){\r\n        // Si se vuelve a la parte superior, se vuelve a ocultar el botón.\r\n        topBtn.style.display = 'none';\r\n    }\r\n})\r\n\r\n/*******************/\r\n\r\n\r\n\r\n/****  TOGGLE THEME FUNCIONALITY  ****/\r\n\r\nlet toggleTheme = document.getElementById('toggleTheme');\r\nlet ball = document.getElementById('ball');\r\nlet theme = localStorage.getItem('theme');\r\n\r\n// Creamos una función que nos permita habiltar el tema oscuro de la página, agregando la clase correspondiente al body y seteando el local storage para guardar el modo.\r\nconst enableDarkTheme = () => {\r\n    document.body.classList.add('dark-theme');\r\n    localStorage.setItem('theme', 'darkTheme');\r\n    ball.style.transform = 'translateX(20px)';\r\n}\r\n\r\n// Creamos una función que nos permita deshabiltar el tema oscuro de la página, removiendo la clase al body y seteando el local storage para guardar el modo.\r\nconst disableDarkTheme = () => {\r\n    document.body.classList.remove('dark-theme');\r\n    localStorage.setItem('theme', 'normal');\r\n    ball.style.transform = 'translateX(0)';\r\n}\r\n\r\ntheme === 'darkTheme' ? enableDarkTheme() : disableDarkTheme();\r\n\r\n// Cuando se aplique el evento click al botón toggle, si el local storage 'theme' no es 'darkTheme', lo habilitamos y sino lo deshabilitamos.\r\ntoggleTheme.addEventListener('click', () => {\r\n    // Actualizamos el local storage cuando se hace click.\r\n    theme = localStorage.getItem('theme');\r\n    theme != 'darkTheme' ? enableDarkTheme() : disableDarkTheme();\r\n});\r\n\r\n/*************************************/\r\n"],"file":"script.js"}